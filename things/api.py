# -*- coding: utf-8 -*-

"""
Module implementing Things API
"""

import os
from shlex import quote

from .database import Database


def tasks(uuid=None, include_items=False, **kwargs):
    """
    Read Tasks into a list of dicts.

    Note: In the database, a Task (capitalized) can be a regular "task",
    a project, or a heading. Per default, this returns only "tasks".
    For details, see the "type" parameter.

    Parameters
    ----------
    uuid : str or None, optional
        Any valid uuid of a Task. If None, then return all Tasks.

    include_items : boolean, default False
        Include items contained within a Task. This can include checklists,
        headings, and "tasks".

    type : {'task', 'project', 'heading', None}, optional, default 'task'
        Only return a specific type of Task:

        'task':     default. Task in a project or a non-project Task;
                    can have a checklist; can link to an area and tags.
        'project':  a large Task. can have "tasks" and headings;
                    can link to an area and tags.
        'heading':  contained within a project in order to group "tasks"
         None:      Return all types of Tasks: "task", project, heading

    status : {'incomplete', 'completed', 'canceled', None}, optional, \
        default 'incomplete'

        Only include Tasks matching that status. If the argument is `None`,
        then include Tasks with any status value.

    start : {'Inbox', 'Anytime', 'Someday', None}, optional
        Only include Tasks matching that start value. If the argument is
        `None` (default), then include Tasks with any start value.

    area : str, bool, or None, optional
        Any valid uuid of an area. Only include Tasks matching that area.
        If the argument is `False`, only include Tasks _without_ an area.
        If the argument is `True`, only include Tasks _with_ an area.
        If the argument is `None`, then ignore the area value, that is,
        include Tasks both with and without a containing area.

    project : str or None, optional
        Any valid uuid of a project. Only include Tasks matching that project.
        If the argument is `False`, only include Tasks _without_ a project.
        If the argument is `True`, only include Tasks _with_ a project.
        If the argument is `None`, then ignore the project value, that is,
        include Tasks both with and without a containing project.

    heading : str or None, optional
        Any valid uuid of a heading. Only include Tasks matching that heading.
        If the argument is `False`, only include Tasks _without_ a heading.
        If the argument is `True`, only include Tasks _with_ a heading.
        If the argument is `None`, then ignore the heading value, that is,
        include Tasks both with and without a containing heading.

    tag : str or None, optional
        Any valid title of a tag. Only include Tasks matching that tag.
        If the argument is `False`, only include Tasks _without_ tags.
        If the argument is `True`, only include Tasks _with_ tags.
        If the argument is `None`, then ignore any tags present, that is,
        include Tasks both with and without tags.

    start_date : bool or None, optional
        If the argument is `False`, only include Tasks _without_ a start date.
        If the argument is `True`, only include Tasks _with_ a start date.
        If the argument is `None`, then ignore the start date value, that is,
        include Tasks both with and without a start date.

    index : {'index', 'todayIndex'}, default 'index'
        Database index to order result by.

    count_only : boolean, default False
        Only output length of result. This is done by a SQL COUNT query.

    filepath : str, optional
        Any valid path of a SQLite database file generated by the Things app.
        If no path is provided, then access the default database path.

    database : things.Database, optional
        Any valid `things.Database` object previously instantiated.

    Returns
    -------
    list of dict (default)
        Representing Things Tasks.
    dict (if `uuid` is given)
        Representing a single Things Task.
    int (count_only == True)
        Count of matching Tasks.

    Examples
    --------
    >>> things.tasks()
    ...
    >>> things.tasks('2Ukg8I2nLukhyEM7wYiBeb')
    ...
    >>> things.tasks(area='hIo1FJlAYGKt1Yj38vzKc3', type=None, include_items=True)
    ...
    >>> things.tasks(status='completed', count_only=True)
    10

    """
    database = pop_database(kwargs)
    result = database.get_tasks(uuid=uuid, **kwargs)

    if kwargs.get("count_only"):
        return result

    # overwrite `include_items` if fetching single uuid for task or heading
    if uuid and result[0]["type"] in ("task", "heading"):
        include_items = True

    for task in result:
        # TK: How costly of an operation is it to do this for every task?
        # IF costly, then can it be made significantly more efficient
        # by optimizing SQL calls?

        if task.get("tags"):
            task["tags"] = database.get_tags(task=task["uuid"])

        if not include_items:
            continue

        # include items
        if task["type"] == "task":
            if task.get("checklist"):
                task["checklist"] = database.get_checklist_items(task_uuid=task["uuid"])
        elif task["type"] == "project":
            project = task
            project["items"] = items = tasks(
                type=None,
                project=project["uuid"],
                include_items=True,
                database=database,
            )
            # tasks without headings appear before headings in app
            items.sort(key=lambda item: item["type"], reverse=True)
        elif task["type"] == "heading":
            heading = task
            heading["items"] = tasks(
                heading=heading["uuid"], include_items=True, database=database
            )

    if uuid:
        result = result[0]

    return result


def areas(uuid=None, include_items=False, **kwargs):
    """
    Read areas into a list of dicts.

    Parameters
    ----------
    uuid : str or None, optional
        Any valid uuid of an area. If None, then return all areas.

    include_items : boolean, default False
        Include tasks and projects in each area.

    tag : str or None, optional
        Any valid title of a tag. Only include areas matching that tag.
        If the argument is `False`, only include areas _without_ tags.
        If the argument is `True`, only include areas _with_ tags.
        If the argument is `None`, then ignore any tags present, that is,
        include areas both with and without tags.

    count_only : boolean, default False
        Only output length of result. This is done by a SQL COUNT query.

    filepath : str, optional
        Any valid path of a SQLite database file generated by the Things app.
        If no path is provided, then access the default database path.

    database : things.Database, optional
        Any valid `things.Database` object previously instantiated.

    Returns
    -------
    list of dict (default)
        Representing Things areas.
    dict (if `uuid` is given)
        Representing a single Things area.
    int (count_only == True)
        Count of matching areas.

    Examples
    --------
    >>> things.areas()
    ...
    >>> things.areas(tag='Home')
    ...
    >>> things.areas(uuid='Gw9QefIdgR6nPEoY5hBNSh')
    ...
    >>> things.areas(include_items=True, status='completed')
    ...
    """
    database = pop_database(kwargs)
    result = database.get_areas(uuid=uuid, **kwargs)

    if kwargs.get("count_only"):
        return result

    for area in result:
        if area.get("tags"):
            area["tags"] = database.get_tags(area=area["uuid"])
        if include_items:
            area["items"] = tasks(
                type=None, area=area["uuid"], include_items=True, database=database
            )

    if uuid:
        result = result[0]

    return result


def tags(title=None, include_items=False, **kwargs):
    """
    Read tags into a list of dicts.

    Parameters
    ----------
    title : str, optional
        Any valid title of a tag. Include all items of said tag.
        If None, then return all tags.

    include_items : boolean, default False
        For each tag, include items tagged with that tag.
        Items may include areas, tasks, and projects.

    area : str, optional
        Valid uuid of an area. Return tags of said area.

    task : str, optional
        Valid uuid of a task. Return tags of said task.

    titles_only : bool, default False
        If True, only return list of titles of tags.

    filepath : str, optional
        Any valid path of a SQLite database file generated by the Things app.
        If no path is provided, then access the default database path.

    database : things.Database, optional
        Any valid `things.Database` object previously instantiated.

    Returns
    -------
    list of dict (default)
        Representing tags.
    list of str (if `titles_only == True` or area / task is given)
        Representing tag titles.
    dict (if `title` is given)
        Representing a single Things tag.

    Examples
    --------
    >>> things.tags()
    ...
    >>> things.tags('Home')
    ...
    >>> things.tags(include_items=True)
    ...
    >>> things.tags(task='2Ukg8I2nLukhyEM7wYiBeb')
    ...
    """
    database = pop_database(kwargs)
    result = database.get_tags(title=title, **kwargs)

    if include_items:
        for tag in result:
            tag_title = tag["title"]
            tag["items"] = [
                *areas(tag=tag_title, database=database),
                *tasks(type=None, tag=tag_title, database=database),
            ]

    if title:
        result = result[0]

    return result


# Utility API functions derived from above


def canceled(**kwargs):
    return tasks(status="canceled", type=kwargs.pop("type", None), **kwargs)


def completed(**kwargs):
    """
    Examples
    --------
    >>> things.completed(count_only=True)
    14
    >>> things.completed(type='project', count_only=True)
    4
    """
    return tasks(status="completed", type=kwargs.pop("type", None), **kwargs)


def get(uuid, **kwargs):
    """
    Find object by uuid.

    Currently supports tasks, projects, headings, areas, and tags.
    """
    try:
        return tasks(uuid=uuid, **kwargs)
    except ValueError:
        pass

    try:
        return areas(uuid=uuid, **kwargs)
    except ValueError:
        pass

    for tag in tags(**kwargs):
        if tag["uuid"] == uuid:
            return tag


def inbox(**kwargs):
    return tasks(start="Inbox", **kwargs)


def projects(uuid=None, **kwargs):
    return tasks(uuid=uuid, type="project", **kwargs)


def today(**kwargs):
    """
    TK: This might still be incomplete. Do a more thorough solution here as needed.
    """
    return tasks(
        start_date=True, index="todayIndex", type=kwargs.pop("type", None), **kwargs
    )


# Interact with Things app


def link(uuid):
    return f"things:///show?id={uuid}"


def show(uuid):
    """
    Show a certain uuid in the Things app.

    Parameters
    ----------
    uuid : str
        A valid uuid of any Things object.

    Examples
    --------
    >>> tag = things.tags('Home')
    >>> things.show(tag['uuid'])
    """
    uri = link(uuid)
    os.system(f"open {quote(uri)}")


# Helper functions


def pop_database(kwargs):
    """instantiate non-default database from `kwargs` if provided"""
    filepath, database = kwargs.pop("filepath", None), kwargs.pop("database", None)
    if not database:
        database = Database(filepath=filepath)
    return database
